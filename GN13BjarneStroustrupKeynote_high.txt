basically, we want simple and efficient and general implementations.

here we got find, if you like C syntax, it is beautiful, if you don't , that's what you've got anyway.

and also we want to parametrized with operations. that is, we parametrized over the container.  we parametrized over the element type, and we parametrized over the actions to be taken. here is the predicate passed to find_if, I want to find anything that meets predicate less_than{"Griffin"}, 

so we generalized find_if that was shown before, if simply uses the predicate, "while we haven't reaches the end , we didn't find predicate and then goes to next one and try again." if the point you finish, you return.

ok, there is spin in c++ various ways since late 80s, early 90s.
so we write a lot of function object, that's the way we represent operations, predicates, etc. they can carry states, that's important.  there are easily inlined , they actually work better in simple cases than an indirect function call. and so here, less_than ( strings) that suppose to take a string you'll compare it to , and then compare when you ask it.
and that's how it was done.

here, take the "Griffin" that's what I want to compare to, and whenever I want to compare, it calls the object.

if you get tired to write these function objects, we can use lambda instead. which is basically a notation that says, give me a function object and use it right here.

so here, I want to , to , to do the  find_all, and I want to compare to the value "Griffin", done.

if you get tired of writing all these begins, you don't have to, you can simply define your own versions that works over a container. it's not perfectly as general as using pairs of iterators, it is notationally much nicer. so here is find_if.

find_if in the container c, that looks  ... odd. 

ok. err...

back to the problem of specifying interfaces. I find that duck typing is in-sufficient,it gives all of those bad messages in addiction to what ever the good it does.

it leaves error detection too late, and it gives compiler writers  too hard job. because there are no proper interfaces. these is no way else says, this is what the algorithms requires over the argument. this is not sit some where , there is no way for us to say it in c++11. that also encourage people to look at the implementation details, because they will look at them anyway. there is no interface that protected them from the details.
and that means, every time you change the implementation of an algorithm, some user might be affected in an surprising way, so that users interest what's inside those abstractions. they are no data abstract.

that leads to people start generalize their implementations so that users ,,so that they have a great user base. this gets to a mass some times.
and further more it doesn't integrate too well with other parts of the language.
you have to teach this kinds of coding in a different way than other kinds of coding.
and you have to to to to think about in a different way. that's not good.
we are not good at keeping one style here, and one style there. it should be better integrated.

so, I think we have to rethink generic code, so that it become similar to the way we think about other code. 
so we need interfaces to get better error messages,  better specification of our algorithms.

so, here is what I like.

here is some traditional code, we have a square root of double, we return to double, we have a double, we call the square root of double with the double, every thing is fine.

that's what we learned in some versions of our long day one of programming class.

and if we give something to square root that isn't a double,
in this case, a pointer to double, we get an error .
that compile time right there, simple, straight forward. 
we all understood that. very simply.
now I want to see the same thing with generic code.

here is a sort, that sorts containers. here's a container.

fine .. we sort the container.

here, when it's time to sort something that's not a container. in this case is a pointer of a container.
and we should get an error right here, and it should be comprehensive. 
so I would like to see a generic programming that's very similar to ordinary programming.

so, this is what we have working with. something called concepts lite. it is also known as constraints, but after people have talking about concepts for a decade, in variably they became concepts.

but since they bundle less than 1/10 of the complexity of the old c++0x concepts, it became concept lite. sorry to Coca-Cola what ever.

basically we try to answer the question how doe we specify requirements on template argument, we want to state the intent and we want point-of-use checking. 
so basically we are provide set of functions that states what we are requiring of an algorithm. so if i have an algorithm for sorts, it will ask for an container. if i had an algorithm that take square root, it ask for a double of positive number.

this is voted as c++14 technical report. technical specification , I believe it's the technical term. I designed by me, Gonçalo dos Reis and Andrew Sutton. Andrew Sutton has the basic implementation of all the basic stuff and most of the details . basically for those of you who have lift through the c++0x concepts, there are not concept maps, there are no new syntax, and there are no scope and look up issues.  
the specification is very much simpler.

so, the first thing we have to ask ourself when working on those, what are concepts? and one of the notions that we came up with what is concepts are fundamental. people were writing specifications that were very very detail in theory. there literally  was 120 concepts in c++ standard library. and look at it, how many concepts are there in the algebra ? a dozen ? is c++ standard library 10 times  complicated as algebra?
I hope not.
it certainly does not have 10 time as many fundamental concepts.
so we have to concentrate on building concepts in a language as what you have that a fundamental application area.

you has to remember that concept comes to classes that describes that area, you don't have a free choice really. if you are dealing with arithmetic, you can't define what it means to subtract, independently what it means to define addition. you can not define multiplication independently of the first two. these things hang together.

is not just syntax, subtractable is not a concept, it's something you can say, but it doesn't make any sense except in the context of something that's specified , say arithmetic.

and we always have concepts. notice that, C have concepts. integer, arithmetic , they are just words in the standard, just like c++ forward iterator, and predicate. just words, in the standard. we want to make it real into code.

so, basically we are looking for some thing fundamental. don't expect to find something fundamental every year.

I don't expect to once we got a body of concept to describe things, I don't expect to fond one every year.

it is not the minimal requirements for an implementation.
if every algorithm is specified as minimal requirement for it's implementation.
we have a problem.

if we want to improve the implementation we have to change the interface.
that's bridle.

what we need to do, is specify interfaces in terms of general concepts, so that we can improve the implementations without affecting the users, we also want to have so few concepts that we actually have a chance of remembering them.

I couldn't remember that sole of concepts in c++0x.
I do expect to be able to remember the concepts in c++14, or 17, what ever. because there will be few hands of them.

Andrew Sutton and me , work on something and we got the STL down to 16 concepts. I believe current version is that thing.

A concept is a predicate on one or more arguments.

we say that T suppose to be a sequence, simply at compile time, we check whether T is a sequence. some where, there's definition of what is it that meets sequence, has an begin an end , for instance, and we just ask if T meets that. if it's a sequence, answer is true, if it's not, answer is false. we can do that on compile time. we have constexpr functions we have functions that can be evaluated at compile time. and we can write things like that.

this is by the way , describe running code, you can download a branch of gcc and try it today.
this is not science fiction.

template declaration will look bit like, you can write like this,

here we have find, basically we have need a sequence S, and we need something for the value type of sequence S can compare equal to that of value type T. and so it takes a sequence and a value of that type.
and now we can write code like that.

it looks exactly as it used to.
the only difference is, we specified find , precisely , so that all the information for checking is available at the point here.
so lets see what happens.

here, we have sortable concept some where, and takes a container. we take one container which is a vector, one container which is a list. and we sort the vector. ok, the vector is sortable. sortable ask for things like random iterator, you can do subscripting like that, every thing is fine. 
sort a list, will fail --  because list is not actually sortable. they don't have the necessary stuff to poke in different parts of an object. 
the best way to sort list is tern to be copy it to a vector, sort and copy it back again.
but that's beyond .. it not on here. --  instead, it gives us an error . 

so here is actual error message from this code. list<int> does not satisfy the constraint 'sortable'. and if you hit, oh . ( in response to applause ) Thank You.

by the way, if you hit another compile option, it will tell you why list is not sortable.
it will come back and tell you .... that it couldn't  ... it it it doesn't know where the scrap ???

but that's .. that's ... en... I like the short version and who likes the longer version.

the shorthand notation is if you don't want to write all of these require stuff, you come upset you can actually write, we need a sequence S, for which the value type of the sequence is equality comparable to the other template argument T. and we can say  iterator T find  ... well.
some people like this notations some people like the others.

you have a choice. (和前面说 template syntax 没有选择呼应了。)

this is just the shorthand. it expand to the required version.

and we can handle essentially all of the Palo Alto technical report.
Palo Alto technical report is a hundred sum page of document specify every algorithm in the STL and this was done by a group of about twenty people in parallel in two years ago. Jon (Jon Kalb) was there, I was there. it was called by Andrew Lumsdaine from Indiana (University ), which is one of the main workers of c++0x concept. and got Alex Stepanov, who is the father of STL , to chair it, and we spend a week, simple specify everything.

so, first, you figure out what you want, and then you figure out how design a language which will do it. that's the right way around ( PS: 他在说 java/go/c# 这种领导拍屁股想出来的语言么？)

don't go and look for fancy language features and see how can can use them.
this idea, that you look for problems that fit your tool is wrong.  so we did the other way around.
all of the work on concept lite is done on applications and find how we can support it.
and we don't have the semantic parts, because , we consider that ... would be too much to handle just now. we don't see problems that checking template(definition) in isolation but we don't do it. that is, we check the use of a template , if a template specify to require something, we assume that the implementation will stick to that contract. we don't actually verify it. we think it can be verified bu you have to be very careful.

those of you who has ... words with strict functional languages like haskell, we know it's really hard to debug, because you made slight change to the implementation, like insert the extern model printf, the interface change, and every thing has to change.  that is painful. 

we didn't want to go that, we need more word experience before we standardized something like that. and we actual use require that much.

overloading is fairly easy. we have two versions of find, one for sequences and one for associative container. if I take a vector or multiset, I try to find something in the vector, it will find the first overload and go and search along. for the second one, it will notice that multiset is an associative container, it will pick the second one , and it will do the search in the associative container, which is certainly not a liner search through it. that works.

and if you look at it, the overloading is based on predicates.
that means, we don't have a notion of a hierarchy refinement  thing. we simply take the predicates, flap them out as boolean expression, see which boolean expression is subset of t other. if it does, we have refinement relation. if not , we just see what works. if it calls one function and not the other, that's fine. if it calls, it can call two, we pick the more specialized one, if we can call two, an they are not specialization of each other, it's an ambiguity error . that's the whole set or rules.

it's just, do event diagram, that ont that ont and that one , finished.

so we compute what the ambiguity resolution it suppose to be, and the classic example here.
we take advance. here is advance that take an input iterator,  here is advance that take a bidirectional iterator, and here is advance that take a random access iterator,  

the are implemented differently. and we are quite capable of piking the right one in all cases.

ok, how did we define it? well that just bool expression so you write bool expressions, bool expressions get tedious so you write functions that are return booleans, this all work in.

to help you write, there is "required(expression)" that takes a expression, if it is valid expression then return true, if not, it just return false. this will suppose to be implementation details, but everybody scream, they want it,  so this not part of the technical specification.

and to recognize them syntactically, I will show you why we need to do that, we call them concept rather than constexpr. we simply take the work constexpr out, and put concept in.
so that they are the same thing except for the syntax analyzer.

how do we get to sort a container? basically, it's a terse notation what I call it.
it means, sorting a container means sorting a type that meets the container requirements.
and that again means give me a type, check the containers requirements on it, and use that type as argument.

so basically these three ?? I use the underscore underscore to show that it's actually not a 
.. it'a generated name that you can't actually refer to. but this is equivalent. 

so if you like to write out the longhand yourself, you will write something like this.

it will assert that it's a container. and we do the stuff. 
so, this is part of this idea of making simple things simple.

this is the simplest algorithms work really nicely for this ?? .
and it looks just like our traditional functions. 
so sort , sorts, no .. sorry, 
square root, take a square root (sqrt) of something that can behave like a double. and include integers.
basically it equals  (  think of the sort function .. no no no ) (that) the square root function has been specified with the predicate that it's argument has be able to behave like a double.

so, we do the same thing more general, with  sort, it requires something that can behave like a container. and we have these predicate for testing it.

now we back to where I want it to be.
here sqrt doubles, this works, it doesn't. sort containers  , this works, and this doesn't
and we get one liner message there.

so, we can start thinking about generic function exactly like other functions, and you know they look like other functions.

now going form the simplest cases to the the more complicated one.
lets see that this actually how well handle the complicated one here. 

here is merge.

it's a .. yeah, it's merge, right there.

it's pretty ugly. it has given many people headaches, including me. if you think that's too easy, try accumulate(). it's even worse.

so we need to get this stuff under control. we look that's just too ugly , too easy to make mistakes, too repetitive , ah, not good enough. so let's try simplify it a bit.

we can say forward iterator for , forward iterator as the shorthand, and we use one requires that predicates these three and check the connections between them. for complicated algorithm that take many arguments, very often you have predicates that takes all of these arguments and works some relation between them. it's a matter fact, i don't think you'll have a good algorithm where there was no relationship at all. at least it's rare and these domain.

and so, this is quite readable, and we are try to attack this problem. if that's your solution, we know what your problem is. you have to simplify. we can simplify even further.

I just said we had a concept that test that three types for mergeable. 
so we have a little notation using ??? it says, give me three types that meet this.
and here are the way i'm using these three types.

we just rap the whole thing up and just say, give me a set of types, that meets my requirements.

so that introduce three names in a scope , " For For2 and Out" which will using here.
and it says that once you give me that in a call, I'll execute the predicate "mergeable" on them to see whether it works.

and, that's the way it looks.

obviously, we take three type names, the first one have to be forward iterator, the second one have to be forward iterator too, not necessary the same forward iterator type. and then we have output iterator, we have assignable requirements and comparable requirements. that's it! just the predicate.

so, this sounds very good. we are of course not finished. that is, there are mush more we can do to improve c++. so let me finish off by looking a bit on the challenges that's facing us. 
there are many and complicated. 

those of you who are to take an Ancient Greek knows this is one of the labors Hercules(Heracles).

he is trying to kill a hydra.

very hard task.

so, c++ challenges.
so, we want to make a better languages , and we also want to convince programmers that the new stuff actually works well.

and that's relatively easy for actually getting people to use in large code bases.  but. we first have to improve the languages and then we have convince people that use worth well.

and then we can start seeing the partials of introducing the existing code bases that doesn't have it.

i refer to that as source code rejuvenation, and I think that is going to be an important issue.  
so basically, what ever we do to the language, what ever we do to change the implementation, we can't eliminate the c++ major strength.  introduce to the language

that is a lot of people has a solutions that ends up been worse that the problem for a large number of people.

compatibility is a feature in itself.
that means that ugly things will not go away even when you provide good alternatives. 
we just have to get people to use the good alternatives where they can. 
so compatibility is necessary.

performance, uncompromising , portability where appropriate , and we would like to increase, not restrict, the application areas.

if we could restrict the application ranges, we could be get a ??? language.
but , actually there is a crew by me from about 1984, then even I can decide a ??? language.

that just wasn't the exercise. it was not the aim of those that use by most useful language for more people for more application areas.

and I think that is very well worth pursuing. 

so the challenge is I would like to close more type loopholes, we need to address concurrent programming, we need some thing that's higher level that the threads, locks style programming which is universal necessary, and about the worse way writing concurrency system that I know of.
we need to build libraries that provide higher model. we want to simply generic programming, I'm looking at concepts, we should .. I means some of us have them today, but we need have them all next year. and we want to simply programming using class hierarchies, I've been doing some work on  ..... multiple methods and functional style. em, some of it is available on my homepage, on the publications, and software also available.
but it's the research work, but I hope some of it gets into the language if not now then later.

you have to think in-long-term in this kinds of stuff.
some times, you have to sort of imagine what the world would like in ten years, and try to get there.
I suppose to thinking , oh ,dear, it will take more than a year, I can't do it. the next quarter is essential ..  on  that kind of thing.
we have to have some longer term thinking.

let's see. better support for ... object oriented generic programming .. get back to that. 
but I don't like the way the community some time fold into different and waring camps when they don't have an need to.

we have to support, combinations of programming styles.
we have to make exception usable for real time project.
one of the things I've said about is that exceptions are not used for hard real time, it can be used for soft real time.
and the reason is very simple. it is, we don't have choise that allow us to estimate how long it takes to recover from an error when exception is thrown. the tools don't exist. I want to build it from 5 years ago but somehow I never get around to it.
been an university students . it became too difficult just because it all to be solved.

it has to be publishable  teachable and fashionable . 

but we need to make exceptions more usable. and we have to deal with multiple address spaces eventually.

the notion that everything works in a single address space is ... it's creaking , it's difficult.
we get these big memories with lots of cores lots of things, but they are uniform any more. 
different memories takes different time to use in such way. I think we need to think about that. access.
we want more domain specific libraries, and we want to develop a better specification of c++.
I think English text is.. err, is ,,, maxing out in terms of what we can handle.

finally I just do a little rant.
I really dislike the word paradigms.
it was invented by coon and imply some superiority of one paradigms over another. and thins changes, everything changes, nor the older stuff became bad.


Kristen Nygaard said, you know, addiction didn't actually become useless just because we invented multiplication, nothing was over turned, you incorporate the old stuff, maybe you have to re-phrase the old stuff. newton mechanism just not disappear just because of Einstein, it became special case, actually a very useful special case.
similarly, I would like to see OOP, GE, and conventional programming just as differential aspects that you can use in combinations and I want be able to develop rules for how you do things that doesn't chock in terms of these paradigms which might become semi religions.

and the focus has become language features , do I write templates do I write virtual functions, that incomplete senses.
so I think it makes harms, it makes things complicated, it grades bad code and people write code for instance, they believe object oriented is right, they are write generic code, use interfaces in virtual functions, which is less convince than templates and long much ??

and similarly you can have people that so believing in generic programming that they make everything into statically resolved overloading and they should have build hierarchy and dynamic solution will much simple and easier to debug and document.

so here is an example of what I mean.

I want to draw all elements in a container. And I want that container to have value type that is the type of the element to be pointers to shapes. fine, and then I want to for each elements in the container, I want to call draw.

now, this is the generalization of the classical object oriented programming draw all shapes. that was first on..  way back in 67.. for useful paradigm. before they have screens that could do this kinds of things. so this is an old program. it's obviously object oriented code. also see here, it's clearly hierarchy of shapes. and there's a virtual function that dispatches to the right kinds of shape. this is object oriented code. obviously it's generic, look , it is parametrized on the kinds of container and you want to do the same to ..  element type ..to that ... and you call for_each algorithm. cleanly cleanly it's generic programming. but it's also very ordinary programming, I just want to draw everything in a container. and I just call a couple of functions on them. it happens to be a lambda, but .. hey, it's just a peace of code that called.

so, I don't believe that you can creditably claim that this one is one and not the other two. it's all three and integrate rather nicely, we have to work on this integration. 

ok, we reach the Q&A time, and .. I'm not sure.. do we have some microphones that people can use? because I barely see people in the back, I certainly can't hear you out there.

so any questions?

this one up there. ah.
